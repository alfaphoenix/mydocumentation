Замыкание (closure) представляет объект функции, который запоминает свое лексическое окружение даже в том случае, когда она выполняется вне своей области видимости.

Технически замыкание включает три компонента:

- внешняя функция, которая определяет некоторую область видимости и в которой определены некоторые переменные и параметры - лексическое окружение
    
- переменные и параметры (лексическое окружение), которые определены во внешней функции
    
- вложенная функция, которая использует переменные и параметры внешней функции
    

В языке Go замыкания реализуются с помощью анонимных функций, поскольку анонимные функции имеют доступ к окружению, в котором они определяются. Например:

```go
func outer() func(){       // внешняя функция
    var n int        // некоторая переменная - лексическое окружение функции inner
    inner := func(){     // вложенная функция
        // действия с переменной n
    }
    return inner
}
```

Рассмотрим замыкания на простейшем примере:

```go
package main
import "fmt"
  
func outer() func(){       // внешняя функция
    var n int = 5        // некоторая переменная - лексическое окружение функции inner
    inner := func(){     // вложенная функция
        // действия с переменной n
        n += 1
        fmt.Println(n)
    }
    return inner
}
  
func main() {
      
    fn := outer()   // fn = inner, так как функция outer возвращает функцию inner
    // вызываем внутреннюю функцию inner
    fn()   // 6
    fn()   // 7
    fn()   // 8
}
```

Здесь функция outer задает область видимости, в которой определены внутренняя функция inner и переменная n. Переменная n представляет лексическое окружение для функции inner. В самой функции inner инкрементируем переменную n и выводим ее значение на консоль. В конце функция outer возвращает функцию inner.

Далее вызываем функцию outer:
```go
fn := outer()
```

Поскольку функция outer возвращает функцию inner, то переменная fn будет хранить функцию inner и иметь тип `func()`. При этом эта функция запомнила свое окружение - то есть внешнюю переменную n.

Далее мы фактически три раза вызываем функцию inner, и мы видим, что переменная n, которая определена вне функции inner, увеличивается на единицу:

```go
fn()   // 6
fn()   // 7
fn()   // 8
```

То есть несмотря на то, что переменная n определена вне функции inner, эта функция запомнила свое окружение и может его использовать, несомотря на то, что она вызывается вне функции outer, в которой была определена. В этом и суть замыканий.

Кстати мы можем сократить определение функции outer, используя анонимную функцию:

```go
func outer() func(){
 
    var n int = 5   
 
    return func(){ 
        n += 1
        fmt.Println(n)
    }
}
```

Рассмотрим другой пример:

```go
package main
import "fmt"
  
func multiply(n int)  func(int) int{
    return func (m int) int {return n * m}
}
 
func main() {
      
    fn := multiply(5)
    result1 := fn(6) // 30
    fmt.Println(result1)       // 30
  
    result2 := fn(5) // 25
    fmt.Println(result2)          // 25
}
```

Итак, здесь вызов функции `multiply()` приводит к вызову другой внутренней функции. Внутренняя же функция:

```go
func (m int) int {return n * m}
```

запоминает окружение, в котором она была создана, в частности, значение параметра n.

В итоге при вызове функции multiply определяется переменная `func`, которая и представляет собой замыкание, то есть объединяет две вещи: функцию и окружение, в котором функция была создана. Окружение состоит из любой локальной переменной или любого параметра, которые были определены в области действия функции multiply во время создания замыкания.

То есть result1 — это замыкание, которое содержит и внутреннюю функцию `func (m int) int {return n * m}`, и параметр n, который существовал во время создания замыкания.

При этом важно не запутаться в параметрах. При определении замыкания:

```go
fn := multiply(5)
```

Число 5 передается для параметра n функции multiply.

При вызове внутренней функции:

```go
result1 := fn(6) // 30
```

Число 6 передается для параметра m во внутреннюю функцию `func (m int) int {return n * m}`

Также мы можем использовать другой вариант для вызова замыкания:

```go
package main
import "fmt"
  
func multiply(n int)  func(int) int{
    return func (m int) int {return n * m}
}
 
func main() {
    result1 := multiply(5)(6) // 30
    fmt.Println(result1)       // 30
}
```

