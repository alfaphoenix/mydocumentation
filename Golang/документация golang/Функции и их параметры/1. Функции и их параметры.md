Функция представляет блок операторов, которые все вместе выполняют какую-то определенную задачу. С помощью функций можно многократно вызывать ее блок операторов как единое целое в других частях программы.

Функция объявляется следующим образом:

```go
func имя_функции (список_параметров)(типы_возвращаемых_значений){
    выполняемые_операторы
}
```

Функция определяется с помощью ключевого слова func, после которого идет имя функции. Затем в скобках идет список параметров. После списка параметров определяются типы возвращаемых из функции значений (если функция возвращает значения). И далее в фигурных скобках идут собственно те операторы, из которых состоит функция.

Название функции вместе с типами ее параметров и типами возвращаемых значений еще называют сигнатурой.

По умолчанию каждая программа на языке Go должна содержать как минимум одну функцию - функцию main, которая является входной точкой в приложение:

```go
package main
import "fmt"
 
func main() {
    fmt.Println("Hello Go")
}
```

Функция main начинается с ключевого слова func, затем идет название - main. Функция не принимает никаких параметров, поэтому после названия идут пустые скобки. Функция main не возвращает никакого результата, поэтому после пустых скобок не указывается тип возвращаемого значения. И тело функции в фигурных скобках фактически состоит из вызова другой функции - `fmt.Println()`, которая выводит строку на консоль.

Теперь определим еще одну функцию:

```go
package main
import "fmt"

func main() {
}
func hello(){
    fmt.Println("Hello METANIT.COM")
}
```

В данном случае мы определили функцию hello, которая не принимает никаких параметров, ничего не возвращает и просто выводит на консоль строку. Определить функцию можно в том же файле, где расположена функция main. Но если мы запустим эту программу, но на консоли мы ничего не увидим. Потому что программа выполняет только те действия, которые определены внутри функции main. Имя она является входной точкой в приложение. И если мы хотим выполнить в программе нашу функцию **hello**, то нам надо вызвать ее в функции main:

```go
package main
import "fmt"
 
func main() {
    hello()
    hello()
    hello()
}
 
func hello(){
    fmt.Println("Hello METANIT.COM")
}
```

Для вызова функции пишется ее имя, после которого в скобках указываются значения для параметров функции. Но поскольку в данном случае функция hello не имеет параметров, то после ее названия пишем просто пустые скобки. И таким образом, при выполнении программы на консоль три раза будет выведена строка "Hello METANIT.COM":

```consol
Hello METANIT.COM
Hello METANIT.COM
Hello METANIT.COM
```

Таким образом, оформление группы операторов в виде функции позволяет не писать каждый раз всю группу операторов, а обращаться к ним по имени функции.

## Параметры функции

Через параметры функция получает входные данные. Параметры указываются в скобках после имени функции. Для каждого параметра указывается имя и тип (как для переменной). Друг от друга параметров разделяются запятыми. При вызове функции необходимо передать значения для всех ее параметров. Например, мы хотим использовать функцию, которая складывает два любых числа:

```go
package main
import "fmt"

funcmain() {
    add(4, 5)   // x + y = 9
    add(20, 6)  // x + y = 26
}

func add(x int, y int){
    var z = x + y
    fmt.Println("x + y = ", z)
}
```

Функция **add** имеет два параметра: x и y. Оба параметра представляют тип int, то есть целые числа. В самой функции определяется переменная, которая хранит сумму этих чисел. И затем сумма чисел выводится на консоль.

В функции main вызывается функция add. Так как функция принимает два параметра, то при вызове ей необходимо передать значения для этих параметров или два аргумента. Причем эти значения должны соответствовать параметрам по типу. То есть если параметр представляет тип int, то ему необходимо передать число.

Значения передаются по позиции. То есть первое значение получит первый параметр, второе значение - входной параметр и так далее. В итоге мы получим следующий консольный вывод:

``` go
x + y = 9
x + y = 26
```

Если несколько параметров подряд имеют один и тот же тип, то мы можем указать тип только для последнего параметра, а предыдущие параметры также будут представлять этот тип:

```go
package main
import "fmt"
 
func main() {
    add(1, 2, 3.4, 5.6, 1.2)
}
func add(x, y int, a, b, c float32){
    var z = x + y
    var d = a + b + c
    fmt.Println("x + y = ", z)
    fmt.Println("a + b + c = ", d)
}
```

В качестве аргументов при вызове функции можно передавать и значения переменных, результаты операций или других функций, но при этом следует учитывать, что аргументы в функцию всегда передаются по значению:

```go
package main
import "fmt"
 
func main() {
    var a = 8
    fmt.Println("a before: ", a)
    increment(a)
    fmt.Println("a after: ", a)
}
func increment(x int){
 
    fmt.Println("x before: ", x)
    x = x + 20
    fmt.Println("x after: ", x)
}
```

Консольный вывод:

```
a before: 8
x before: 8
x after: 28
a after: 8
```

В данном случае в качестве аргумента в функцию increment передается значение переменной a. Параметр x получает это значение, и оно увеличивается на 20. Однако несмотря на то, что значение параметра x увеличилось, значение переменной a никак не изменилось. Потому что при вызове функции передается копия значения переменной.

## Неопределенное количество параметров

В Go функция может принимать неопределенное количество параметров одного типа. Например, нам надо получить сумму чисел, но мы точно не знаем, сколько чисел будут переданы в функцию:

```go
package main
import "fmt"
 
func main() {
    add(1, 2, 3)        // sum = 6
    add(1, 2, 3, 4)     // sum = 10
    add(5, 6, 7, 2, 3)  // sum = 23
}
 
func add(numbers ...int){
    var sum = 0
    for _, number := range numbers{
        sum += number
    }
    fmt.Println("sum = ", sum)
}
```

Для определения параметра, который представляет неопределенное количество значений, перед типом этих значений ставится многоточие: `numbers ...int`. То есть через подобный параметр мы получаем несколько значений типа int.

При вызове мы можем передать в функцию add разное количество чисел:

```go
add(1, 2, 3)        // sum = 6
add(1, 2, 3, 4)     // sum = 10
add(5, 6, 7, 2, 3)  // sum = 23
```

От этого случае следует отличать передачу среза в качестве параметра:

```go
add([]int{1, 2, 3})
add([]int{1, 2, 3, 4})
add([]int{5, 6, 7, 2, 3})
```

В данном случае мы получим ошибку, так как передача среза не эквивалентна передаче неопределенного количества параметров того же типа. Если мы хотим передать срез, то надо указать после аргумента-массива многоточие:

```go
add([]int{1, 2, 3}...)
 
add([]int{1, 2, 3, 4}...)
 
var nums = []int{5, 6, 7, 2, 3}
add(nums...)
```


[[3. Функции Go]]

#go 