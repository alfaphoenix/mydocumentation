
Константы, как и переменные, хранят некоторые данные, но в отличие от переменных значения констант нельзя изменить, они устанавливаются один раз. Вычисление констант производится во время компиляции. Благодаря этому уменьшается количество работы, которую необходимо произвести во время выполнения, упрощается поиск ошибок, связанных с константами (так как некоторые из них можно обнаружить на момент компиляции).

Для определения констант применяется ключевое слово const:
```go
const pi float64 = 3.1415
```

И в отличие от переменной мы не можем изменить значение константы. А если и попробуем это сделать, то при компиляции мы получим ошибку:
```go
const pi float64 = 3.1415
pi = 2.7182  // ! Ошибка
```

Константы можно инициализировать только константными значениями, например, литералами типа чисел или строк, или значениями других констант. Но инициализировать константу значением переменной мы не можем:
```go
var m int = 7
// const k = m      // ! Ошибка: m - переменная
const s = 5 // Норм: 5 - числовая константа
const n = s // Норм: s - константа
```
### Множественное определение констант

В одном определении можно объявить разу несколько констант:

```go
const (
	pi float64 = 3.1415
	e float64 = 2.7182
)
```

или так:

```go
const pi, e = 3.1415, 2.7182
```

Если у константы не указан тип, то он выводится неявно на основании того значения, которым инициализируется константа:

```go
const n = 5  //  тип int
```

В то же время необходимо обязательно инициализировать константу начальным значением при ее объявлении. Например, следующие определения констант являются недопустимыми, так как они не инициализируются:

```go
const d  // ошибка
const n int  // ошибка
```
### Автоматическая инициализация констант

Если определяется последовательность констант, то инициализацию значением можно опустить для всех констант, кроме первой. В этом случае константа без значения получит значение предыдущей константы:

```go
const (
	a = 1
	b
	c
	d = 3
	f
)
fmt.Println(a, b, c, d, f)      // 1, 1, 1, 3, 3
```
### iota-идентификатор

Go поддерживает идентификатор **Iota**, который увеличивается с объявлением каждой новой константы. Всякий раз, когда компилятор получает блок `const`, идентификатор **iota** сбрасывается до нуля и увеличивается на единицу после каждой непустой строки в блоке `const`:

```go
package main
import "fmt"

func main() {
	const // iota сбрасывается в 0
	(
		C0 = iota // здесь iota равно 0, увеличивается с каждой строкой
		C1 // увеличение на 1, iota равна 1
		C2 = iota // iota равна 2
	)
	fmt.Println("C0:", C0) // C0: 0
	fmt.Println("C1:", C1) // C1: 1
	fmt.Println("C2:", C2) // C2: 2
	const //  iota сбрасывается в 0
	(
		C3 = iota  // С3 = 0
	)
	fmt.Println("C3:", C3) // C3: 
}
```

[[2. Основы языка Go]]
#go 
