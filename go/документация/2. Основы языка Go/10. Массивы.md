Массивы представляют последовательность элементов определенного типа. Массив определяется следующим способом:

```go
var имя [число_элементов]тип_элементов
```

Например, массив из пяти элементов типа int: 

```go
var numbers [5]int
```

При таком определении все элементы массива инициализируются значениями по умолчанию. Но также можно инициализировать элементы массива другими значениями:

```go
var numbers [5]int = [5]int{1,2,3,4,5}
```

Значения передаются в фигурных скобках через запятую. При этом значений не может быть больше длины массива. В данном случае длина массива равна 5, поэтому нельзя в фигурных скобках определить больше пяти элементов. Но можно определить меньше элементов:

```go
var numbers [5]int = [5]int{1,2}
fmt.Println(numbers)    // [1 2 0 0 0]
```

В этом случае элементы, для которых не указано значение, будут иметь значение по умолчанию.

Также можно применять сокращенное определение переменной массива:

```go
numbers := [5]int {1,2,3,4,5}
//или 
a := [...]int{0, 2, 4, 6, 8}
```

Если в квадратных скобках вместо длины указано троеточие, то длина массива определяется, исходя из количества переданных ему элементов:

```
`var` `numbers = [...]``int``{1,2,3,4,5}`   `// длина массива 5`
`numbers2 := [...]``int``{1,2,3}`         `// длина массива 3`
`fmt.Println(numbers)`                `// [1 2 3 4 5]`
`fmt.Println(numbers2)`           `// [1 2 3]`
```

При этом длина массива является частью его типа. И, к примеру, следующие два массива представляют разные типы данных, хотя они и хранят данные одного типа:

```
`var` `numbers [3]``int` `= [3]``int``{1, 2, 3}`
`var` `numbers2 [4]``int` `= [4]``int``{1, 2, 3, 4}`
`numbers = numbers2`  `// ! Ошибка`
```

И в данном случае при присвоении мы получим ошибку, так как данные одного типа пытаемся передать переменной другого типа.

## Индексы

Для обращения к элементам массива применяются индексы - номера элементов. При этом нумерация начинается с нуля, то есть первый элемент будет иметь индекс 0. Индекс указывается в квадратных скобках. По индексу можно получить значение элемента, либо изменить его:

```
`package` `main`

`import` `"fmt"`

`func` `main() {`

    `var` `numbers [5]``int` `= [5]``int``{1,2,3,4,5}`

    `fmt.Println(numbers[0])`     `// 1`

    `fmt.Println(numbers[4])`     `// 5`

    `numbers[0] = 87`

    `fmt.Println(numbers[0])`     `// 87`

`}`
```

Индексы в массиве фактически выступают в качестве ключей, по которым можно обратиться к соответствующему значению. И в прицнипе мы можем явным образом указать, какому ключу какое значение будет соответствовать. При этому числовые ключи необязательно располагать в порядке возрастания:

```
`colors := [3]``string``{2:` `"blue"``, 0:` `"red"``, 1:` `"green"``}`

`fmt.Println(colors[2])`      `// blue`
```

## Многомерные массивы

Выше рассматривались только одномерные массивы, то есть такие массивы, которые можно представить в виде строки или столбика элементов (грубо говоря количество размерностей соответствует количеству пар квадратных скобок в объявлении массива). Но кроме одномерных массивов мы можем определять и многомерные массивы, которые можно определить как массивы массива. Многомерный массив можно разбить на несколько одномерных массивов. В таких массивах данные хранятся в табличной форме (порядок по строкам). Размер многомерного массива определяется его размерами, которые равны произведению размеров всех размерностей.

Многомерные массивы объявляются следующим образом:

```
Имя_массива := [размерность_1][размерность_2]..тип_массива{значения_массива}
```

Количество квадратных скобок указывает количество размерностей массива. Простейшее определение двухмерного массива:

```
`package` `main`

`import` `"fmt"`

`func` `main() {`

    `numbers := [3][2]` `int` `{`

        `{1, 2},`

        `{4, 5},`

        `{7, 8},`

    `}`

    `fmt.Println(numbers)`   `// [[1 2] [4 5] [7 8]]`

`}`
```

В данном случае numbers представляет двумерный массив (с двумя размерностями) размером 3x2. Объявление массива (`numbers := [3][2] int`) означает, что он содержит три одномерных массива, где каждый одномерный массив имеет длину в два элемента. Двухмерный массив еще можно представить в виде таблицы:

| 1   | 2   |
| --- | --- |
| 4   | 5   |
| 7   | 8   |

Как и в случае с одномерными массивами, нет необходимости инициализировать многомерный массив всеми элементами. Неинициализированные элементы массивов получают значения по умолчанию. Например:

```
`numbers := [3][2]` `int` `{`

    `{1, 2},`

    `{5},`

`}`

`fmt.Println(numbers)` `// [[1 2] [5 0] [0 0]]`
```

Для обращения к элементам многомерного массива применяются индексы, причем для каждой размерности указывается свой индекс. Например:

```
`package` `main`

`import` `"fmt"`

`func` `main() {`
    `var` `numbers [3] [2]` `int`
    `numbers[0] = [2]` `int` `{1, 2}`
    `numbers[1] = [2]` `int` `{4, 5}`
    `numbers[2] = [2]` `int` `{7, 8}`
    `fmt.Println(numbers)`  `// [[1 2] [4 5] [7 8]]`
`}`
```

В данном случае numbers представляет набор из 3 массивов, каждый из который содержит по 2 элемента. Для инициализации каждого подмассива применяем соответствующий индекс. Например, инициализация самого первого подмассива:

```
`numbers[0] = [2]` `int` `{1, 2}`
```

Фактически каждый такой подмассив представляет строку в таблице. А каждый элемент такого подмассива - столбец.

Также мы могли бы обратиться к конкретному элементу, используя оба индекса:

```
`package` `main`

`import` `"fmt"`

`func` `main() {`

    `var` `numbers [3] [2]` `int`

    `numbers[0][0] = 1`

    `numbers[0][1] = 2`

    `numbers[1][0] = 4`

    `numbers[1][1] = 5`

    `numbers[2][0] = 7`

    `numbers[2][1] = 8`

    `fmt.Println(numbers)`  `// [[1 2] [4 5] [7 8]]`

`}`
```

Например, выражение:

| 1   | 2     |
| --- | ----- |
| 4   | **5** |
| 7   | 8     |
## Длина массивов

Для получения длины массива Go предоставляет встроенную функцию len(), которая возвращает количество элементов массива:

```
`package` `main`

`import` `"fmt"`

`func` `main() {`

    `numbers := [...]` `int` `{3, 4, 5, 6}`

    `fmt.Println(``"Numbers length:"``, len(numbers))`    `// Numbers length: 4`

`}`
```

Для многомерных массивов функция **len()** возвращает размер только первой размерности массива. Например:

```
package main
import "fmt"

func main() {

	numbers := [3][2] int {
		{1},
		{7},
    }

	fmt.Println("Numbers values:", numbers)         // Numbers values: [[1 0] [7 0] [0 0]
	fmt.Println("Numbers length:", len(numbers))    // Numbers length: 3
}
```

Здесь двухмерный массив имеет в совокупности 3 * 2 = 6 элементов, хотя инициализированы только два из них. Однако реальная длина по функции `len()` равна 3, так как первая размерность (количество строк) равна 3.

## Сравнение массивов

Два массива называются равными, если они оба имеют одинаковый тип и размер, имеют одинаковые элементы, и все элементы находятся в одинаковом порядке в обоих массивах. Для сравнения массивов применяется стандартный оператор сравнения `==`. Он возвращает `true`, если оба массива равны, в противном случае `false`. Сначала он проверяет тип данных обоих массивов, а затем сопоставляет значения по индексу:

```
`package` `main`

`import` `"fmt"`

`func` `main() {`

    `nums1 := [4]` `int` `{3, 4, 5, 6}`

    `nums2 := [4]` `int` `{3, 4, 5}`

    `fmt.Println(``"nums1 == nums2:"``, nums1==nums2)` `// false`

    `nums3 := [3][2]` `int` `{ {2}, {5}, }`

    `nums4 := [3][2]` `int` `{ {2, 1}, {5}, }`

    `fmt.Println(``"nums3 == nums4:"``, nums3==nums4)`   `// false`

    `nums5 := [4]` `int``{3, 4, 5, 0}`

    `fmt.Println(``"nums2 == nums5:"``, nums2==nums5)`  `// true`

`}`
```

## Копирование массива

Копирование массива — это просто присвоение одного массива другому. Поскольку в Go массив ведет себя как значение, а не как ссылка, то изменение любого значения одного массива не оказывает никакого влияния на другой.

```
package main
import "fmt"

func main() {
	nums1 := [4] int {3, 4, 5, 6}
	nums2 := nums1  // копирование массива nums1 в nums2
	
	nums2[1] = 11 // меняем значение в nums2, nums1 не меняется
	
	fmt.Println("nums1:", nums1)// nums1: [3 4 5 6]
	fmt.Println("nums2:", nums2)// nums2: [3 11 5 6]
}
```

[[2. Основы языка Go]]

