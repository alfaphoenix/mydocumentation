Циклы позволяют в зависимости от определенного условия выполнять некоторые действия множество раз. Фактически в Go есть только один цикл - цикл for, который может принимать разные формы. Этот цикл имеет следующее формальное определение:

```go
for [инициализация счетчика]; [условие]; [изменение счетчика]{     
	// действия
}
```

Например, выведем с помощью цикла квадраты чисел:

```go
package main
import "fmt"

func main() {

    for i := 1; i < 10; i++{
        fmt.Println(i * i)
    }
}
```

Объявление цикла for разбивается на три части. Вначале идет инициализация счетчика: `i := 1`. Фактически она представляет объявление переменной, которая будет использоваться внутри цикла. В данном случае это счетчик i, начальное значение которого равно 1.

Вторая часть представляет условие: `i < 10`. Пока это условие истинно, то есть возвращает true, будет продолжаться цикл.

Третья часть представляет изменение (увеличение) счетчика на единицу.

В теле цикла на консоль выводится квадрат числа i.

Таким образом, цикл сработает 9 раз, пока значение i не станет равным 10. И каждый раз это значение будет увеличиваться на 1. Каждый отдельный проход цикла называется итерацией. То есть в данном случае будет 9 итераций. В итоге мы получим следующий консольный вывод:

```
1
4
9
16
25
36
49
64
81
```

Нам необязательно указывать все условия при объявлении цикла. Например, можно вынести объявление переменной вовне:

```
`var` `i = 1`
`for` `; i < 10; i++{`
    `fmt.Println(i * i)`
`}`
```

Можно убрать изменение счетчика в само тело цикла и оставить только условие:

```
var i = 1
for ; i < 10;{
    fmt.Println(i * i)
    i++
}
```

Если цикл использует только условие, то его можно сократить следующим образом:

```
var i = 1
for i < 10 {
    fmt.Println(i * i)
    i++
}
```

можно написать бесконечный цикл (while)

```go
var i = 1
for {
    fmt.Println(i * i)
    i++
}
```
## Вложенные циклы

Циклы могут быть вложенными, то есть располагаться внутри других циклов. Например, выведем на консоль таблицу умножения:

```
`package` `main`
`import` `"fmt"`

`func` `main() {`

    `for` `i := 1; i < 10; i++{`
        `for` `j := 1; j < 10; j++{`
            `fmt.Print(i * j,` `"\t"``)`
        `}`
        `fmt.Println()`
    `}`
`}`
```

вывод:
```
1	2	3	4	5	6	7	8	9	
2	4	6	8	10	12	14	16	18	
3	6	9	12	15	18	21	24	27	
4	8	12	16	20	24	28	32	36	
5	10	15	20	25	30	35	40	45	
6	12	18	24	30	36	42	48	54	
7	14	21	28	35	42	49	56	63	
8	16	24	32	40	48	56	64	72	
9	18	27	36	45	54	63	72	81
```

## Перебор наборов данных

Ряд типов данных представляют набор данных. Например, строка может быть представлена как набор символов. Кроме того, в Go есть комплексные типы, которые представляют коллекции данных, в частности, массивы, срезы, словари. Для перебора наборов данных в языке Go есть специальная форма цикла **for**:

```
for индекс, значение := range набор_данных{
    // действия
}
```

После ключевого слова **for** указываются индекс и значение элемента набора, а после оператора **range** указывается перебираемый набор данных. Данный цикл перебирает все элементы набора данных и получает индекс этого элемента (номер элемента в наборе начиная с 0), и значение этого элемента.

Например, переберём строку:

```
`package` `main`
`import` `"fmt"`

`func` `main() {`

    `str :=` `"Hello"`
    `for` `index, value :=` `range` `str {`
        `fmt.Println(``"Index:", index, " Value:", value)`
    `}`
`}`
```

В данном случае получаем индекс каждого символа строки str в переменную `index`, а каждый символ - в переменную `value` и выводим все это на консоль:

```
Index: 0  Value: 72
Index: 1  Value: 101
Index: 2  Value: 108
Index: 3  Value: 108
Index: 4  Value: 111
```

Здесь мы видим, что значением каждого символа строки является его числовой код. Но попробуем перевести код символа в читабельную форму:

```
package main
import "fmt"

func main() {
	str := "Hello"
	for index, value := range str {
		fmt.Printf("Index: %d, Value: %c\n", index, value)
	}
}
```

```
Index: 0, Value: H
Index: 1, Value: e
Index: 2, Value: l
Index: 3, Value: l
Index: 4, Value: o
```

Если мы не планируем использовать значения или индексы элементов, то мы можем вместо них указать прочерк. Например, нам не нужны индексы:
```
`package` `main`
`import` `"fmt"`

`func` `main() {`

    `str :=` `"Hello"`
    `for` `_, value :=` `range` `str {`
        `fmt.Printf(``"%c "``, value)`
    `}`
    `fmt.Printf(``"%c "``,10)`
`}`
```

Аналогично мы можем перебирать и остальные типы наборов данных. Например, переберём массив строк:

```
`var` `users = [3]``string``{``"Tom"``,` `"Alice"``,` `"Kate"``}`
`for` `index, value :=` `range` `users{`
    `fmt.Println(index, value)`
`}`
```

Консольный вывод:

```
0 Tom
1 Alice
2 Kate
```

Но также для перебора массива можно использовать и стандартную версию цикла **for**:

```
var users = [3]string{"Tom", "Alice", "Kate"}
for i:= 0; i < len(users); i++{
    fmt.Println(users[i])
}
```

В данном случае счетчик i играет роль индекса. Цикл выполняется, пока счетчик i не станет равным длине массива, которую можно получить с помощью функции len()

## Операторы break и continue

Может возникнуть ситуация, когда нам надо при определенных условиях завершить текущую итерацию цикла, не выполнять все инструкции цикла, а сразу перейти к следующей итерации. В этом случае можно использовать оператор continue. Например, в массиве могу быть, как положительные, так и отрицательные числа. Допустим, нам нужна сумма только положительных чисел, поэтому, если нам встретится отрицательное число, мы можем просто перейти к следующей итерации с помощью continue:

```
var numbers = [10]int{1, -2, 3, -4, 5, -6, -7, 8, -9, 10}
var sum = 0

for _, value := range numbers{
	if value < 0{
		continue  // переходим к следующей итерации
	}
	sum += value
}
fmt.Println("Sum:", sum)    // Sum: 27
```

Оператор **break** используется для немедленного выхода из цикла (как правило, при определенном условии):

```
`var` `numbers = [10]``int``{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}`
`var` `sum = 0`

`for` `_, value :=` `range` `numbers{`
    `if` `value > 4{`
        `break`       `// если число больше 4 выходим из цикла`
    `}`
    `sum += value`
`}`
`fmt.Println(``"Sum:"``, sum)`    `// Sum: 10`
```

Оператор **break** нередко применяется для выхода из вложенных циклов. Для этого оператору передается метка - на нее проецируется цикл, из которого надо выйти. Например:

```
package main
import "fmt"

func main() {

// метка для перехода к внешнему циклу
OuterLoop:
	for i := 1; i <= 3; i++ {
		for j := 1; j <= 3; j++ {
			fmt.Printf("i = %d, j = %d\n", i, j)
			if i == 2 && j == 2 {
				fmt.Println("Выход из внешнего цикла...")
				break OuterLoop // выходим из внешнего цикла
			}
		}
	}
	fmt.Println("Цикл завершен...")
}
```

В данном случае у нас два цикла - внешний цикл по i и вложенный по j. Внешний цикл предваряется меткой OuterLoop. Во вложенном цикле, если переменные i и j одновременно равны 2, то выходим из цикла. Однако если бы мы, просто использовали оператор **break** без метки, то произошел бы выход только из вложенного цикла к следующей итерации внешнего цикла. Однако мы передаем оператору **break** метку OuterLoop:

```
break OuterLoop
```

Метка OuterLoop проецируется на внешний цикл, поэтому при выполнении этого оператора **break** произойдет выход из внешнего цикла. Консольный вывод программы:

```
i = 1, j = 1
i = 1, j = 2
i = 1, j = 3
i = 2, j = 1
i = 2, j = 2
Выход из внешнего цикла...
Цикл завершен...
```

