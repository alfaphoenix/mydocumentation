---
tags: [golang, basics, functions, closures]
aliases: [Go Функции, Go Замыкания]
---

# ⚙️ Функции

## 1. Объявление Функций

Функции объявляются с помощью ключевого слова `func`.

```go
func add(x int, y int) int {
	return x + y
}

// Если типы параметров одинаковы, можно опустить тип у всех, кроме последнего
func addSimplified(x, y int) int {
	return x + y
}
```

## 2. Множественные Возвращаемые Значения

Функции в Go могут возвращать несколько значений. Это часто используется для возврата результата и ошибки.

```go
func swap(x, y string) (string, string) {
	return y, x
}

func main() {
	a, b := swap("hello", "world")
	fmt.Println(a, b) // world hello
}
```

## 3. Именованные Возвращаемые Значения

Возвращаемым значениям можно дать имена. Если они названы, они рассматриваются как переменные, определенные в начале функции.

```go
func split(sum int) (x, y int) {
	x = sum * 4 / 9
	y = sum - x
	return // Голый return возвращает именованные переменные x и y
}
```

> **Лучшая практика:** Используйте **голый `return`** только в коротких функциях. В длинных функциях это может ухудшить читаемость.

## 4. Вариативные Функции (Variadic Functions)

Функции, которые могут принимать переменное число аргументов.

```go
func sum(nums ...int) {
	total := 0
	for _, num := range nums {
		total += num
	}
	fmt.Println(total)
}

func main() {
	sum(1, 2)
	sum(1, 2, 3, 4)

	// Передача среза в вариативную функцию
	nums := []int{10, 20, 30}
	sum(nums...)
}
```

## 5. Замыкания (Closures)

Go поддерживает анонимные функции, которые могут обращаться к переменным, определенным вне тела функции.

```go
func adder() func(int) int {
	sum := 0 // Переменная, к которой будет иметь доступ замыкание
	return func(x int) int {
		sum += x
		return sum
	}
}

func main() {
	pos, neg := adder(), adder() // Каждое замыкание имеет свою собственную переменную sum
	for i := 0; i < 5; i++ {
		fmt.Println(
			pos(i),
			neg(-2*i),
		)
	}
}
```

## 6. `defer`

Инструкция `defer` откладывает выполнение функции до тех пор, пока окружающая функция не вернет управление. Отложенные вызовы функций помещаются в стек.

```go
func main() {
	fmt.Println("counting")

	for i := 0; i < 10; i++ {
		defer fmt.Println(i) // Вызовы будут выполнены в порядке LIFO (9, 8, 7, ...)
	}

	fmt.Println("done")
}
```
